using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace Transpiler
{
    public class Transpiler
    {
        private readonly IFileWriter fileWriter;
        private readonly Configuration config;

        public Transpiler(Configuration config)
        {
            this.config = config;
            this.fileWriter = new DefaultFileWriter();
        }

        public Transpiler(Configuration config, IFileWriter fileWriter)
        {
            this.config = config;
            this.fileWriter = fileWriter;
        }

        public void Run(IEnumerable<Type> types)
        {
            this.fileWriter.CreateDirectory(this.config.TargetDirectory);

            var tsTypes = this.CreateTsTypes(types);

            foreach (var tsType in tsTypes)
            {
                var imports = new List<string>();
                var body = new List<string>();

                var filePath = Path.Combine(tsType.Directory, $"{tsType.Name}.ts");

                if (this.config.PrintGeneratedFileText)
                {
                    imports.Add("// This file was generated by the CS2TS-Transpiler");
                    imports.Add(string.Empty);
                }

                var genericAddon = tsType.GenericArguments.Any()
                    ? $"<{string.Join(", ", tsType.GenericArguments)}>"
                    : string.Empty;
                body.Add($"export interface {tsType.Name}{genericAddon} {{");

                var properties = tsType.Type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);
                foreach (var prop in properties)
                {
                    this.CreatePropertyLines(prop, tsType, tsTypes, imports, body);
                }

                body.Add("}");

                this.fileWriter.CreateFile(filePath, this.CombineLines(imports, body));
            }
        }

        IEnumerable<TsType> CreateTsTypes(IEnumerable<Type> types)
        {
            foreach (var t in types)
            {
                var subFolders = this.config.UseNamespacesAsFolders
                    ? this.config.MapNamespace(t.Namespace).Replace(".", "\\")
                    : string.Empty;

                yield return new TsType
                {
                    Id = t.FullName,
                    Name = this.GetTypeName(t),
                    Directory = Path.Combine(this.config.TargetDirectory, subFolders.Trim('\\')),
                    GenericArguments = t.GetGenericArguments().Select(x => x.Name).ToList(),
                    Type = t
                };
            }
        }

        void CreatePropertyLines(PropertyInfo property, TsType tsType, IEnumerable<TsType> tsTypes, List<string> imports, List<string> body)
        {
            var propertyType = property.PropertyType;

            var isEnumerable = propertyType != typeof(string)
                && typeof(IEnumerable).IsAssignableFrom(propertyType);

            if (isEnumerable)
                propertyType = propertyType.GetGenericArguments().First();

            if (propertyType.IsGenericParameter)
            {
                body.Add($"    {property.Name}: {propertyType.Name}{(isEnumerable ? "[]" : string.Empty)};");

                return;
            }

            // possible TsType
            var otherTsType = tsTypes.SingleOrDefault(t => t.Id == propertyType.FullName);

            if (otherTsType == null)
            {
                body.Add($"    {property.Name}: {this.TsTypeName(propertyType)}{(isEnumerable ? "[]" : string.Empty)};");
            }
            else
            {
                var relPath = this.CreateRelativeDirectoryPath(tsType.Directory, otherTsType.Directory);
                imports.Add($"import {{ {otherTsType.Name} }} from \"{relPath + otherTsType.Name}\";");
                body.Add($"    {property.Name}: {otherTsType.Name}{(isEnumerable ? "[]" : string.Empty)};");
            }
        }

        List<string> CombineLines(List<string> imports, List<string> body)
        {
            var fileLines = new List<string>();
            fileLines.AddRange(imports);
            if (imports.Any() && !string.IsNullOrWhiteSpace(imports.Last())) fileLines.Add(string.Empty);
            fileLines.AddRange(body);

            return fileLines;
        }

        string CreateRelativeDirectoryPath(string fromDirectoryPath, string toDirectoryPath)
        {
            if (!fromDirectoryPath.EndsWith("\\")) fromDirectoryPath += "\\";
            var fromUri = new Uri(fromDirectoryPath);
            if (!toDirectoryPath.EndsWith("\\")) toDirectoryPath += "\\";
            var toUri = new Uri(toDirectoryPath);

            var relativePath = fromUri.MakeRelativeUri(toUri).ToString();

            return relativePath.StartsWith("..") ? relativePath : "./" + relativePath;
        }

        string GetTypeName(Type type)
        {
            if (!type.IsGenericType) return type.Name;

            return type.Name.Split('`')[0];
        }

        string TsTypeName(Type propType)
        {
            var tsTypeName = "any";

            var isNullable = propType.IsValueType && Nullable.GetUnderlyingType(propType) != null;
            if (isNullable)
                propType = Nullable.GetUnderlyingType(propType);

            if (propType.Name == typeof(int).Name) tsTypeName = "number";
            if (propType.Name == typeof(string).Name) tsTypeName = "string";
            if (propType.Name == typeof(Guid).Name) tsTypeName = "string";
            if (propType.Name == typeof(bool).Name) tsTypeName = "boolean";
            if (propType.Name == typeof(DateTime).Name) tsTypeName = "Date";
            if (propType.Name == typeof(DateTimeOffset).Name) tsTypeName = "Date";

            if (isNullable)
                tsTypeName = tsTypeName + " | null";

            return tsTypeName;
        }
    }
}
