using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;

namespace Transpiler
{
    public class Transpiler
    {
        private readonly IFileWriter fileWriter;
        private readonly Configuration config;

        public Transpiler(Configuration config)
        {
            this.config = config;
            this.fileWriter = new DefaultFileWriter();
        }

        public Transpiler(Configuration config, IFileWriter fileWriter)
        {
            this.config = config;
            this.fileWriter = fileWriter;
        }

        public void Run(IEnumerable<Type> types)
        {
            this.fileWriter.CreateDirectory(this.config.TargetDirectory);

            var tsTypes = types.Select(t =>
            {
                var subFolders = this.config.UseNamespacesAsFolders
                    ? this.config.MapNamespace(t.Namespace).Replace(".", "\\")
                    : "";

                return new
                {
                    Id = t.FullName,
                    Name = t.Name,
                    Directory = Path.Combine(this.config.TargetDirectory, subFolders.Trim('\\')),
                    Type = t
                };
            });

            foreach (var type in types)
            {
                var imports = new List<string>();
                var content = new List<string>();
                var fileName = $"{type.Name}.ts";
                var subFolders = this.config.UseNamespacesAsFolders
                    ? this.config.MapNamespace(type.Namespace).Replace(".", "\\")
                    : "";
                var directory = Path.Combine(this.config.TargetDirectory, subFolders.Trim('\\'));
                var filePath = Path.Combine(directory, fileName);

                if (this.config.PrintGeneratedFileText)
                {
                    imports.Add("// This file was generated by the CS2TS-Transpiler");
                    imports.Add("");
                }

                content.Add($"export interface {type.Name} {{");

                var properties = type.GetProperties(BindingFlags.Public | BindingFlags.Instance | BindingFlags.DeclaredOnly);

                foreach (var prop in properties)
                {
                    var pt = prop.PropertyType;

                    // possible TsType
                    var tsType = tsTypes.SingleOrDefault(t => t.Id == pt.FullName);
                    if (tsType == null)
                    {
                        content.Add($"    {prop.Name}: {this.TsTypeName(pt)};");
                    }
                    else
                    {
                        var relPath = this.CreateRelativePath(directory, tsType.Directory);
                        imports.Add($"import {{ {tsType.Name} }} from \"{relPath + tsType.Name}\";");
                        content.Add($"    {prop.Name}: {tsType.Name};");
                    }
                }

                content.Add("}");

                var fileLines = new List<string>();
                fileLines.AddRange(imports);
                if (imports.Any() && !string.IsNullOrWhiteSpace(imports.Last())) fileLines.Add("");
                fileLines.AddRange(content);
                this.fileWriter.CreateFile(filePath, fileLines);
            }

        }

        string CreateRelativePath(string fromDirectoryPath, string toDirectoryPath)
        {
            if (!fromDirectoryPath.EndsWith("\\")) fromDirectoryPath += "\\";
            var fromUri = new Uri(fromDirectoryPath);
            if (!toDirectoryPath.EndsWith("\\")) toDirectoryPath += "\\";
            var toUri = new Uri(toDirectoryPath);

            var relativePath = fromUri.MakeRelativeUri(toUri).ToString();

            return relativePath.StartsWith("..") ? relativePath : "./" + relativePath;
        }

        string TsTypeName(Type propType)
        {
            var tsTypeName = "any";

            var isEnumerable = propType != typeof(string) && typeof(IEnumerable).IsAssignableFrom(propType);

            var isNullable = propType.IsValueType && Nullable.GetUnderlyingType(propType) != null;
            if (isNullable)
                propType = Nullable.GetUnderlyingType(propType);

            if (isEnumerable)
                propType = propType.GetGenericArguments().First();

            if (propType.Name == typeof(int).Name) tsTypeName = "number";
            if (propType.Name == typeof(string).Name) tsTypeName = "string";
            if (propType.Name == typeof(Guid).Name) tsTypeName = "string";
            if (propType.Name == typeof(bool).Name) tsTypeName = "boolean";
            if (propType.Name == typeof(DateTime).Name) tsTypeName = "Date";
            if (propType.Name == typeof(DateTimeOffset).Name) tsTypeName = "Date";

            if (isNullable)
                tsTypeName = tsTypeName + " | null";

            if (isEnumerable)
                tsTypeName = tsTypeName + "[]";

            return tsTypeName;
        }
    }
}



